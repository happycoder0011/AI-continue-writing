/**
 * EDITOR STATE MACHINE
 * 
 * This file defines the state machine for our AI writing assistant using XState.
 * A state machine helps us manage the different states our editor can be in and
 * the transitions between those states.
 * 
 * Think of it like a traffic light:
 * - It can be in states: RED, YELLOW, GREEN
 * - It transitions between states based on events (timer expires)
 * - Each state has specific behaviors
 * 
 * Our editor has these states:
 * - idle: Ready for user input
 * - generating: AI is creating content
 * - review: AI content is ready for user to accept/reject
 * - error: Something went wrong
 */

import { createMachine, assign } from 'xstate';
import { generateAIContent } from '../services/aiService';

/**
 * Create the editor state machine
 * 
 * @returns {StateMachine} The configured state machine
 */
export const editorMachine = createMachine(
  {
    // Unique identifier for this machine
    id: 'editor',
    
    // The initial state when the app starts
    initial: 'idle',
    
    // Context is like the machine's memory - it stores data that persists across states
    context: {
      // The current document content from ProseMirror
      editorState: null,
      
      // The text generated by AI (stored temporarily until user accepts/rejects)
      generatedContent: '',
      
      // Any error message if something goes wrong
      errorMessage: '',
      
      // The position in the document where AI content should be inserted
      cursorPosition: 0,
      
      // Flag to indicate if the last transition was a discard action
      shouldDiscardContent: false,
      
      
      // Flag to indicate if the last transition was an accept action
      shouldAcceptContent: false,
    },
  
  // Define all possible states and their behaviors
  states: {
    /**
     * IDLE STATE
     * The editor is ready and waiting for user action
     * User can type normally or trigger AI generation
     */
    idle: {
      // When entering idle state, clear any previous errors
      entry: [
        assign({
          errorMessage: () => '',
          generatedContent: () => '',
        }),
        () => console.log('üü¢ Entered IDLE state')
      ],
      
      // Events that can happen in idle state and where they lead
      on: {
        // User clicks "Continue Writing" button
        CONTINUE_CLICK: {
          target: 'generating',
          // Save the cursor position before generating
          actions: [
            assign({
              cursorPosition: (context, event) => event.cursorPosition,
            }),
            (context, event) => console.log('üîÑ CONTINUE_CLICK received, cursorPosition:', event.cursorPosition)
          ],
        },
        
        // User presses keyboard shortcut (Ctrl+Space or Cmd+Space)
        KEYBOARD_SHORTCUT: {
          target: 'generating',
          actions: assign({
            cursorPosition: (context, event) => event.cursorPosition,
          }),
        },
        
        // Update editor state when user types
        EDITOR_UPDATE: {
          actions: assign({
            editorState: (context, event) => event.editorState,
          }),
        },
        
        // Clear the discard flag after editor has handled it
        DISCARD_HANDLED: {
          actions: [
            assign({
              shouldDiscardContent: () => false,
            }),
            () => console.log('üßπ DISCARD_HANDLED: Cleared shouldDiscardContent flag')
          ],
        },
        
        
        // Clear the accept flag after editor has handled it
        ACCEPT_HANDLED: {
          actions: [
            assign({
              shouldAcceptContent: () => false,
            }),
            () => console.log('üßπ ACCEPT_HANDLED: Cleared shouldAcceptContent flag')
          ],
        },
      },
    },
    
    /**
     * GENERATING STATE
     * AI is actively creating content
     * User cannot edit during this time
     */
    generating: {
      // Add entry logging
      entry: () => console.log('üîÑ Entered GENERATING state'),
      
      // 'invoke' means "run this async function while in this state"
      invoke: {
        // Reference the service defined in the services configuration
        src: 'generateContent',
        
        // What to do when the function succeeds
        onDone: {
          target: 'review',
          // Store the generated content in context
          actions: [
            assign({
              generatedContent: (context, event) => event.data,
            }),
            (context, event) => console.log('‚úÖ Generation completed, moving to REVIEW state. Content:', event.data)
          ],
        },
        
        // What to do if the function fails
        onError: {
          target: 'error',
          // Store the error message
          actions: [
            assign({
              errorMessage: (context, event) => event.data?.message || 'Failed to generate content',
            }),
            (context, event) => console.log('‚ùå Generation failed, moving to ERROR state. Error:', event.data)
          ],
        },
      },
    },
    
    /**
     * REVIEW STATE
     * AI has generated content and is showing it to the user
     * User can now accept, clear, or discard the content
     */
    review: {
      entry: () => console.log('üìù Entered REVIEW state'),
      on: {
        // User clicks "Accept All" - keep the AI content
        USER_ACCEPT: {
          target: 'idle',
          // The content is already in the editor, just clear the temporary storage
          actions: [
            assign({
              generatedContent: () => '',
              shouldAcceptContent: () => true,
            }),
            () => console.log('‚úÖ USER_ACCEPT: Set shouldAcceptContent to true')
          ],
        },
        
        // User clicks "Discard Session" - revert to before AI generation
        USER_DISCARD: {
          target: 'idle',
          // Clear generated content and signal to revert editor state
          actions: [
            assign({
              generatedContent: () => '',
              shouldDiscardContent: () => true,
            }),
            () => console.log('üóëÔ∏è USER_DISCARD: Set shouldDiscardContent to true')
          ],
        },
      },
    },
    
    /**
     * ERROR STATE
     * Something went wrong during AI generation
     * Show error message and allow retry
     */
    error: {
      entry: (context) => console.log('üö® Entered ERROR state with message:', context.errorMessage),
      on: {
        // User clicks "Retry"
        RETRY: 'generating',
        
        // User clicks "Dismiss" error
        DISMISS: 'idle',
      },
    },
  }
},
{
    // Services configuration (XState v4 style)
    services: {
      generateContent: async (context) => {
        try {
          // Extract text from editor state
          console.log("üîç generateContent service started with context:", context);
          const documentText = context.editorState?.doc?.textContent || "";
          const cursorPos = context.cursorPosition;
          console.log("üìù Document text:", documentText);
          console.log("üìç Cursor position:", cursorPos);
          
          // Call our AI service (defined in aiService.js)
          console.log("ü§ñ Calling generateAIContent...");
          const generatedText = await generateAIContent(documentText, cursorPos);
          console.log("‚úÖ AI generation successful:", generatedText);
          
          return generatedText;
        } catch (error) {
          console.error("‚ùå Error in generateContent service:", error);
          throw error; // Re-throw to trigger onError transition
        }
      }
    }
  }
);

/**
 * USAGE EXAMPLE:
 * 
 * import { useMachine } from '@xstate/react';
 * import { editorMachine } from './machines/editorMachine';
 * 
 * function MyComponent() {
 *   const [state, send] = useMachine(editorMachine);
 *   
 *   // Check current state
 *   const isGenerating = state.matches('generating');
 *   
 *   // Send events
 *   send({ type: 'CONTINUE_CLICK', cursorPosition: 100 });
 *   
 *   // Access context data
 *   const content = state.context.generatedContent;
 * }
 */
